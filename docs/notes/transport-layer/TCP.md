# TCP 笔记

## 概述

TCP 协议是对上层应用提供可靠数据传输的协议，也是端系统到端系统进程间通信的桥梁。点对点的传输，只能一个发送方和接收方建立连接，不能一对多或者多对多。
管道化（流水线），发送方和接收方缓存。全双工数据，在同一连接数据流双向流动。面向连接，在数据交换之前，通过握手初始化发送方/接收方状态变量（比如 sepNum ackNum 初始化）。
这里的连接是说双方保持一个连接状态。流量控制，发送方/接收方都有缓存区域，双方互传数据是都会带上自己的现有缓存窗口大小，告知对方我目前只能接收这么多数据量，控制对方的发送量。
拥塞控制

## TCP 协议报文段

![Image text](./image/1643253805(1).png)

TCP 协议报文段头部 20 个字节

* 源端口号 2 个字节
* 目标端口 2 个字节
* 序号（sepNum） 4 个字节：报文段首字节的在字节流的编号
* 确认号（ackNum）  4 个字节：期望从另一方收到的下一个字节的序号（累积确认）
* 首部长度
* 保留位
* 标志位：
  * URG: 紧急指针标志，为 1 时表示紧急指针有效，为 0 则忽略紧急指针。
  * ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。
  * PSH：为 1 表示是带有 push 标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。
  * RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。
  * SYN：为1表示这是连接请求或是连接接受请求，用于创建连接和使顺序号同步
  * FIN：用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流。
* 接收窗口：表示从确认号开始，本报文的接受方可以接收的字节数，即接收窗口大小，用于流量控制。
* 检验和
* 紧急数据指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。
* 可选和填充部分：长度可变，定义其他的一些可选参数
* 数据部分：可以存在，也可以不存在

## TCP 合理设置超时时间

设置合理的超时时间是提升 TCP 协议性能的重要指标，时间定太长和太短都不好。那如何设置超时时间了

* SampleRTT：测量从报文段发出到收到确认的时间，对几个最近的测量值求平均，而不是仅用当前的 SampleRTT

先要计算一个评估值：

EstimatedRTT = (1 - a)*EstimatedRTT（上一次的评估值） + a*SampleRTT

* 指数加权移动平均
* 过去样本的影响呈指数衰减
* 推荐值：a = 0.125

设置超时：

(推荐值：b = 0.25)

DevRTT = (1-b)*DevRTT + b*|SampleRTT-EstimatedRTT|

超时时间间隔设置为：

TimeoutInterval = EstimatedRTT + 4*DevRTT

## TCP 的可靠数据传输

TCP 要向上层应用提供可靠数据传输，可是 TCP 下层有是不可靠的网络层（IP）协议，TCP 要如何建立可靠数据传输服务提供给上层应用了

* 数据不出错
* 数据不丢失
* TCP 另外还增加流量控制机制
* 拥塞控制机制

保证数据不出错和保证数据不丢失在 rdt 协议中怎么一步步实现描述很清楚

TCP 和 GBN（回退N重传协议） SR（选择重传协议） 的联系

* TCP 是管道化的报文端，和 GBN SR 一致
* 累计确认，像 GBN
* 单个重传定时器，像 GBN
* 是否可以接受乱序的，没有规范，实现者可以自由发挥
* 重传只重发最早的那个未确认报文端，像 SR

在抛开重复的确认和流量控制和拥塞控制，看看发送方如何发送：

* 从应用层接收数据：
  * 从应用层接收数据，用 nextseq 创建报文段，序号 nextseq 为报文段首字节的字节流编号，如果还没有运行，启动定时器，定时器与最早未确认的报文段关联。
* 超时：
  * 重传后沿最老的报文段
  * 重新启动定时器
* 收到确认：
  * 如果是对尚未确认的报文段确认
  * 更新已被确认的报文序号
  * 如果当前还有未被确认的报文段，重新启动定时器

nextseq 的是怎么样的了，首先应用层下来的报文可能很大，到了传输层会把应用层的报文打成小段，也就是 MSS 部分，nextseq初始化等于 字节流中 MSS 中的首个字节数。

MSS 的计算：

TCP报文段头部是 20 字节，IP 数据报头部也是 20 字节，如果链路层的帧大小只能控制在 1500 ，那么从应用层拿到的报文必须打成 1500 - 20 - 20 = 1460 大小的 MSS，这里的 1460 就是 MSS。

MTU：最大链路层帧长度，以太网和 PPP 链路层协议具有 1500 字节的 MTU，因此 MSS 的典型值为 1460 字节（TPC/IP 首部长度通常为 40 字节）。

发送方：

1. 首先是三次握手，第一次握手序号（nextseq）从随机的一个值开始，三次握手后开始传递数据，序号累计到字节流中的 MSS 首个字节

2. 如果还没有运行，启动定时器，定时器与最早未确认的报文段关联（TimeOutInterval）

3. 发送缓冲区内的报文端，缓冲区有发送未确认的段，前沿（NextSeqNum）向前滑动

4. 收到确认后，后沿（SendBase）向前滑动，定时器重启指向最后还未确认的段

5. 后沿与前沿重合说明已经没有要发送的段了，关闭定时器

![Image text](./image/1643353788(1).png)

接收方：

1. 在接收缓冲区内，所期望的序号报文段按顺序到达，所以期望序号之前的数据都已经被确认。此时延迟 ACK ， 对另一个按序报文段的到达最多等待500ms（两个报文段一起确认）。如果下一个报文段在这个时间间隔内没有到达，则发送一个ACK。

2. 有期望序号的报文段到达。另一个按序报文段等待发送ACK，立即发送单个累积ACK，以确认两个按序报文段。

3. 比期望序号大的报文段乱序到达。检测出数据流中的间隔。立即发送重复的ACK，指明下一个期待字节的序号。

4. 能部分或完全填充接收数据间隔的报文段到达。若该报文段起始于间隔（gap）的低端，则立即发送ACK。

### 重传

发送方定时器触发重传，接收方按顺序收到到最高字节确认。（累计确认）

![Image text](./image/1643354737(1).png)

### 快速重传

1. 有时候超时周期往往会太长，在重传丢失报文段之前的延时太长

2. 通过重复的 ACK 来检测报文段丢失

3. 如果发送方收到同一数据的 3 个冗余 ACK，不等超时直接重传最小序号的段

![Image text](./image/1643355011(1).png)

### TCP 的三次握手

在传输数据之前，TCP 要建立一个连接，准确点的说法是面向连接，客户端与服务器端各自保持一个连接的状态。

下面考虑一个问题，为什么不是两次握手，两次握手会带来半连接的问题

1. 首先发送方发送建立连接的请求

2. 接收方响应确认连接的

3. 如果就这样两次握手后就开始传输数据了

4. 有可能的情况是发送方没及时收到接收方的连接建立确认，定时器超时，重新发送连接建立请求

5. 接收发有会帮这次请求当做一次新的建立连接的请求，这样会导致接收方维护了很多半连接

![Image text](./image/1643356866(1).png)

三次握手创建连接就可以避免这种情况的发生

1. 一般第三次握手是和传输数据报文段一起

2. 如果像上面讲的那样，因为超时重新发送连接连接的请求

3. 此刻接收方等待是发送方第二次的（指的是第三次握手）建立连接的确认

4. 如果是因为超时重发的建立连接请求会被接收方忽略掉

5. 如果是发送方第三次握手还没到达接收方，就开始传输数据报文段了，接收方也是会直接忽略掉数据报文段，（接收方的自白：你都还没给我建立连接，发送什么数据）。

6. TCP 的报文段可以是乱序发送的，上面 5 的情况很有可能发送。

![Image text](./image/1643357694(1).png)

### TCP 的关闭连接

1. 客户端，服务器分别关闭它自己这一侧的连接 

2. 发送FIN bit = 1 的 TCP 头部段

### 流量控制

1. 在 TCP 协议的报文段中有个“接收窗口（rwnd）” 的字段，该字段是用来 “通告” 发送方其缓冲区空闲 buffer 大小。 RcvBuffer 大小通过 socket 选项设置 (典型默认大小为4096 字节)

2. 发送方收到 rwnd 大小后会限制未确认认(“in-flight”)字节个数 <= 接收方 rwnd 值

3. 达到一个发送方/接收方数据传输中的一个平衡，确保接收方不会被传输过来的数据淹没

![Image text](./image/1643356113(1).png)

### 拥塞控制

为什么会拥塞，非正式的定义: “太多的数据需要网络传输，超过了网 络的处理能力”，与流量控制不同，拥塞的表现：

* 分组丢失 (路由器缓冲区溢出)
* 分组经历比较长的延迟(在路由器的队列中排队)

TCP 是端到端的拥塞控制，路由器不向主机有关拥塞的反馈信息，端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作。

考虑拥塞控制的几个问题：

* 如何检测拥塞，拥塞又分：轻微拥塞， 拥塞
* 控制策略：在拥塞发送时如何动作，降低速率
* 在拥塞缓解时如何动作，增加速率

检测拥塞：
1. 某个段超时了（丢失事件 ）：拥塞
2. 有关某个段的3次重复ACK：轻微拥塞

拥塞控制策略：
1. 慢启动
2. AIMD：线性增、乘性减少
3. 超时事件后的保守策略

速率控制方法（发送方）：
1. 维持一个拥塞窗口的值：CongWin
2. 发送端限制已发送但是未确认的数据量（的上限）:LastByteSent-LastByteAcked <= CongWin
3. 从而粗略地控制发送方的往网络中注入的速率

#### 慢启动

当连接开始时，指数性增加（每个RTT）发送速率直到发生丢失事件，每一个RTT， CongWin加倍，每收到一个ACK时，CongWin加1（why）慢启动阶段：只要不超时 或 3个重复ack，一个RTT， CongWin加倍

总结: 初始速率很慢，但是加速却是指数性的 ，指数增加，SS时间很短，长期来看可以忽略

#### AIMD

乘性减:丢失事件后将CongWin降为1， 将CongWin/2作为阈值，进入慢启动阶段（倍增直到CongWin/2）

加性增：当CongWin>阈值时，一个 RTT 如没有发生丢失事件 ,将 CongWin 加 1 MSS: 探测

当收到3个重复的ACKs: CongWin 减半，窗口（缓冲区大小）之后线性增长

当超时事件发生时：CongWin被设置成 1 MSS，进入SS阶段，之后窗口指数增长，增长到一个阈值（上次发生拥塞的窗口的一半）时，再线性增加